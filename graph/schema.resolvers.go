package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"hw11_shopql/graph/model"
	"hw11_shopql/pkg/session"
	"hw11_shopql/pkg/utils/sessionutils"
	"strconv"
)

// Items is the resolver for the items field.
func (r *catalogResolver) Items(ctx context.Context, obj *model.Catalog, limit *int, offset *int) ([]*model.Item, error) {
	if limit == nil {
		x := 3
		limit = &x
	}
	if offset == nil {
		y := 0
		offset = &y
	}
	items, err := r.ItemRepo.GetItemsByCatalogID(context.Background(), obj.ID, *limit, *offset)
	if err != nil {
		return nil, err
	}
	return items, err
}

// Seller is the resolver for the seller field.
func (r *itemResolver) Seller(ctx context.Context, obj *model.Item) (*model.Seller, error) {
	seller, err := r.SellerRepo.LookupSellerById(ctx, obj.SellerID)
	if err != nil {
		return nil, err
	}
	return seller, err
}

// Parent is the resolver for the parent field.
func (r *itemResolver) Parent(ctx context.Context, obj *model.Item) (*model.Catalog, error) {
	catalog, err := r.CatalogRepo.LookupCatalog(ctx, obj.CatalogID)
	if err != nil {
		return nil, err
	}
	// fmt.Println(catalog)
	// catalog, err = r.CatalogRepo.LookupCatalog(ctx, *catalog.ParentID)
	// if err != nil {
	// 	return nil, err
	// }
	// fmt.Println(catalog)
	return &catalog, err
}

// Rate is the resolver for the rate field.
func (r *itemResolver) Rate(ctx context.Context, obj *model.Item) (float64, error) {
	rate, err := r.ItemRepo.ItemsRate(ctx, obj.ID)
	if err != nil {
		fmt.Println(err)
		return 0, err
	}
	fmt.Println(rate)
	return rate, nil
}

// InCart is the resolver for the inCart field.
func (r *itemResolver) InCart(ctx context.Context, obj *model.Item) (int, error) {
	session := ctx.Value("tokens").(*session.Session)
	cart, err := r.CartRepo.GetCartsItem(ctx, int(session.UserID), obj.ID)
	if err != nil {
		return 0, nil
	}
	return cart.Quantity, nil
}

// RateItem is the resolver for the RateItem field.
func (r *mutationResolver) RateItem(ctx context.Context, in *model.RateInput) (*model.Item, error) {
	session := ctx.Value("tokens").(*session.Session)
	item, err := r.ItemRepo.RateItem(ctx, int(session.UserID), in.ItemID, in.Rate)
	if err != nil {
		return nil, err
	}
	return item, err
}

// AddToCart is the resolver for the AddToCart field.
func (r *mutationResolver) AddToCart(ctx context.Context, in *model.CartInput) ([]*model.CartItem, error) {
	session := ctx.Value("tokens").(*session.Session)
	err := r.CartRepo.AddItem(ctx, in, int(session.UserID))
	if err != nil {
		return nil, err
	}
	cartItems, err := r.CartRepo.GetCartItems(ctx, int(session.UserID))
	if err != nil {
		panic(err)
	}
	return cartItems, err
}

// RemoveFromCart is the resolver for the RemoveFromCart field.
func (r *mutationResolver) RemoveFromCart(ctx context.Context, in *model.CartInput) ([]*model.CartItem, error) {
	session := ctx.Value("tokens").(*session.Session)
	err := r.CartRepo.RemoveFromCartItem(ctx, in, int(session.UserID))
	if err != nil {
		return nil, err
	}
	cartItems, err := r.CartRepo.GetCartItems(ctx, int(session.UserID))
	if err != nil {
		panic(err)
	}
	return cartItems, err
}

// AddCommentToItem is the resolver for the AddCommentToItem field.
func (r *mutationResolver) AddCommentToItem(ctx context.Context, in *model.CommentInput) (*model.Comment, error) {
	userID := ctx.Value("tokens").(*session.Session).UserID
	comment, err := r.ItemRepo.AddComment(ctx, int(userID), in.ItemID, in.CommentText)
	if err != nil {
		return nil, err
	}
	return comment, nil
}

// AddCommentToComment is the resolver for the AddCommentToComment field.
func (r *mutationResolver) AddCommentToComment(ctx context.Context, in *model.CommentToCommentInput) (*model.Comment, error) {
	userID := ctx.Value("tokens").(*session.Session).UserID
	comment, err := r.ItemRepo.AddCommentToCommnet(ctx, int(userID), in.CommentID, in.CommentText)
	if err != nil {
		return nil, err
	}
	return comment, nil
}

// CreateAnOrder is the resolver for the CreateAnOrder field.
func (r *mutationResolver) CreateAnOrder(ctx context.Context, in *string) (*model.Order, error) {
	userID, err := sessionutils.IdFromContex(ctx)
	if err != nil {
		return nil, err
	}
	order, err := r.OrderRepo.CreateOrder(ctx, userID)
	if err != nil {
		return nil, err
	}
	return order, nil
}

// AddItem is the resolver for the AddItem field.
func (r *mutationResolver) AddItem(ctx context.Context, in model.ItemInput) (*model.Item, error) {
	item, err := r.ItemRepo.AddItem(ctx, in)
	if err != nil {
		return nil, err
	}
	return item, nil
}

// AddCatalog is the resolver for the AddCatalog field.
func (r *mutationResolver) AddCatalog(ctx context.Context, in model.CatalogInput) (*model.Catalog, error) {
	catalog, err := r.CatalogRepo.AddCatalogWithItems(ctx, in)
	if err != nil {
		return nil, err
	}
	return catalog, nil
}

// AddRoleForUser is the resolver for the AddRoleForUser field.
func (r *mutationResolver) AddRoleForUser(ctx context.Context, in *model.UserRole) (*model.UserInfo, error) {
	err := r.RoleRepo.AddRoleForUser(in.UserID, in.RoleID)
	if err != nil {
		return nil, err
	}
	return &model.UserInfo{in.RoleID, in.UserID}, nil
}

// Catalog is the resolver for the Catalog field.
func (r *queryResolver) Catalog(ctx context.Context, id *string) (*model.Catalog, error) {
	id1, err := strconv.Atoi(*id)
	if err != nil {
		return nil, err
	}
	catalog, err := r.CatalogRepo.LookupCatalog(ctx, id1)
	if err != nil {
		return nil, err
	}
	return &catalog, err
}

// Seller is the resolver for the Seller field.
func (r *queryResolver) Seller(ctx context.Context, id string) (*model.Seller, error) {
	id1, err := strconv.Atoi(id)
	seller, err := r.SellerRepo.LookupSellerById(ctx, id1)
	if err != nil {
		return nil, err
	}
	return seller, err
}

// MyCart is the resolver for the MyCart field.
func (r *queryResolver) MyCart(ctx context.Context) ([]*model.CartItem, error) {
	session := ctx.Value("tokens").(*session.Session)
	cartItems, err := r.CartRepo.GetCartItems(ctx, int(session.UserID))
	if err != nil {
		return nil, err
	}
	return cartItems, err
}

// MyOrders is the resolver for the MyOrders field.
func (r *queryResolver) MyOrders(ctx context.Context) ([]*model.Order, error) {
	UserID, err := sessionutils.IdFromContex(ctx)
	if err != nil {
		return nil, err
	}
	userOders, err := r.OrderRepo.UsersOrders(ctx, UserID)
	if err != nil {
		return nil, err
	}
	return userOders, nil
}

// UserOrders is the resolver for the UserOrders field.
func (r *queryResolver) UserOrders(ctx context.Context, id int) ([]*model.Order, error) {
	userOders, err := r.OrderRepo.UsersOrders(ctx, id)
	if err != nil {
		return nil, err
	}
	return userOders, nil
}

// UserCards is the resolver for the UserCards field.
func (r *queryResolver) UserCards(ctx context.Context, id int) ([]*model.CartItem, error) {
	userCart, err := r.CartRepo.GetCartItems(ctx, id)
	if err != nil {
		return nil, err
	}
	return userCart, nil
}

// Items is the resolver for the items field.
func (r *sellerResolver) Items(ctx context.Context, obj *model.Seller, limit *int, offset *int) ([]*model.Item, error) {
	if limit == nil {
		x := 3
		limit = &x
	}
	if offset == nil {
		y := 0
		offset = &y
	}
	items, err := r.ItemRepo.GetItemsBySellerID(ctx, obj.ID, limit, offset)
	if err != nil {
		return nil, err
	}
	for _, item := range items {
		switch item.InStock {
		case 1:
			item.InStockText = "pdf"
		}
	}
	return items, err
}

// Catalog returns CatalogResolver implementation.
func (r *Resolver) Catalog() CatalogResolver { return &catalogResolver{r} }

// Item returns ItemResolver implementation.
func (r *Resolver) Item() ItemResolver { return &itemResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Seller returns SellerResolver implementation.
func (r *Resolver) Seller() SellerResolver { return &sellerResolver{r} }

type catalogResolver struct{ *Resolver }
type itemResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type sellerResolver struct{ *Resolver }
